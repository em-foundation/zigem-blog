{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":""},{"location":"post-001/","title":"The EM language is dead, long live EM !!!","text":"<p>For the past fifteen years, the focus of the EM Programming Language has remained constant \u2013 producing \"tiny code for tiny chips\" where every byte of memory and \u03bcJoule of energy matters.\u2009  But now, I may have unwittingly come upon a better means\u2009 towards this end.</p> <p>\u21b7</p> <p></p>"},{"location":"post-001/#if-you-cant-beat-emzigem","title":"If you can't beat 'em,\u2002Zig\u2022EM","text":"<p>My zeal to promote EM earlier this year blinded me to the challenges of sustaining a novel programming language for resource-constrained embedded systems.\u2009  Supporting just a handful of developers over the past decade pales in comparison with the effort demanded to render EM openly and freely available to the broader embedded community.</p> <p>My (rhetorical) question to the community about the need to move beyond C (towards EM, of course\u2009!!\u2009) elicited a mixed bag of reactions \u2013 from \"cool, good luck\" \u2009to \"sorry, try again\"\u2009.\u2009 But then, I received this most consequential of comments which turned on the lights for me:\u00a0</p> <p>\"With a language like Zig I don't think there's need for EM\"</p> <p>FULL DISCLOSURE \u2013 You don't know what you don't know</p> <p>I pride myself on staying informed about the latest directions in programming language design and imple\u00admentation.\u2009  For me, programming languages lie at the heart of Computer Science; and for me, conceiving and evolving the EM language provided a personal path to the discipline's core.</p> <p>Honestly, I'd never even heard\u2009 of Zig when first receiving this comment several months ago.  While attending the Embedded World Conference in N\u00fcrnberg shortly thereafter, I informally polled dozens of attendees; and with the exception of my esteemed colleague Jeremy Bennett, no one had heard of the Zig programming language either.\u2009  Several folks did, however, know about zigbee\u00ae \u2013 which you'd expect from this crowd. </p> <p>Like EM, Zig offers higher-level programming with higher-levels of performance when compared with C; and Zig regularly earns high-marks when held up against other modern systems programming languages like Go and Rust \u2013 both already targeting embedded MCUs.</p> <p>But unlike the competition, Zig offers an inherent simplicity and transparency reminiscent of C \u2013 the incumbant systems programming language which some believe Zig could supplant.</p> <p>First released in early 2016, the Zig community supporting and sustaining this novel language continues to cast its net further and wider.\u2009 Compared with Go and Rust, however, Zig very much remains a work in progress \u2013 while capturing new followers (like me) on a daily basis.</p> <p>If you haven't already googled \"Zig programming language\", visit ziglang.org as a starting point.</p> <p>Suffice it say, far more folks have already lined up behind Zig than would ever even hear of the EM programming language.  To that end, I've decided to \"downgrade\" EM to a programming framework leveraging Zig as its host language \u2013 which finally leads us to Zig\u2022EM.</p> <p>It's Zig all the way down...</p> <p>As described here, the current rendition of EM \u2013 a transpiler written in TypeScript \u2013 generates a meta-program (implemented in NodeJS) whose hosted execution shapes a downstream run-time program (implemented in C/C++); the latter then compiles into firmware targeting some resource-constrained MCU platform.</p> <p>In the case of Zig\u2022EM, it will use just one language throughout its implementation \u2013 resulting in a 10\u2715 reduction in the amount of code I'll need to maintain; I can also leverage ZLS, an implementation of Microsoft's Language Server Protocol which enables Zig integration with VSCode and other popular IDEs.</p> <p>And above all, you can direct all questions\u2009/\u2009comments about the Zig language to the Zig community \u2013 as will I.</p> <p>As its overarching goal, the Zig\u2022EM framework strives to reconstitute the novel concepts and constructs first introduced within EM by using design-time patterns, build-time tooling, and run-time services \u2013 all leveraging the latest stable release of the Zig programming language.</p>"},{"location":"post-001/#plans-are-worthless","title":"Plans are worthless\u2009...","text":"<p>... but planning is everything\u2009.(1)\u00a0  Given our unanticipated change of course, let's set some new objectives for evolving the Zig\u2022EM framework through the remainder of this year:</p> <ol> <li>General Dwight D. Eisenhower,34th President of the United States</li> </ol> <p>focus exclusively on supporting the TI CC2340R5, which served as the initial hardware platform when EM debuted late last year; my enthusiasm for this wireless MCU hasn't waned in the interim\u2009!!</p> <p>create a suite of basic Zig\u2022EM examples \u2013 mimicking the dozen EM programs originally described here\u2009 \u2013 which would then illustrate how the framework maps EM constructs onto the Zig language</p> <p>benchmark the runtime performance of Zig\u2022EM in terms of program size, execution time, and power consumption \u2013 using our suite of basic examples along with a Zig-based re-work of EM\u2022Mark</p> <p>push forward with Zig\u2022EM support for the CC2340R5's 2.4\u2009GHz radio \u2013 eventually re-creating the minimalist BLE stack described here and measuring its performance against TI's legacy C code</p> <p>maintain a public Git repository containing the Zig\u2022EM framework source code \u2013 written entirely in Zig from the ground-up, and made openly available under an unconstrained MIT license</p> <p>I'll try to post regular updates on progress towards these objectives, along with some high-level tours as Zig\u2022EM takes shape.\u2009  Let's see what happens, as we do live in interesting times\u2009!!</p>"},{"location":"post-001/#how-you-can-get-involved","title":"How you can get involved","text":"<p>explore the Zig language \u2013 I highly recommend Karl Sequin's Learning Zig as a starting-point</p> <p>experience the \"Zen of Zig\" at the Ziggit forum \u2013 a refreshing respite from the rants at Reddit</p> <p>read my first post about Zig\u2022EM to the Zig dev community  \u2013 then sign-up and send me some </p> <p>Happy coding\u2009!!! \u2002  </p>"},{"location":"post-002/","title":"Announcing Zig\u2022EM v25.0.1","text":"<p>With support from The EM Foundation, we announce the initial release of Zig\u2022EM \u2013 a novel programming framework for developing and deploying applications which target resource-constrained MCUs, where every byte of memory and every \u03bcJoule of energy matters.</p> <p>\u21b6</p>"},{"location":"post-002/#setting-expectations","title":"Setting expectations","text":"<p>As rationalized in our previous post, Zig\u2022EM strives to reconstitute\u2009 core concepts and constructs of the EM Programming Language into Zig \u2013 a system programming language favorably compared with Go and Rust, but with the simplicity and transparency of C. </p> <p>But downgrading the EM language into a programming framework hosted by Zig does introduce some challenges.\u2009 For one, the Zig language itself remains a work-in-progress; reaching an \"official\" Zig 1.0 release will realistically require years of effort.(1)</p> <ol> <li>see Andrew Kelley's Zig 2024 Roadmap talk</li> </ol> <p>Furthermore, Zig eschews much of the \"syntactic flexibility\" (operator overloading, optional lexical elements, etc) found in contemporary languages ranging from C++ to Ruby \u2013 leaving us with a somewhat rudimentary set of programmatic mechanisms to realize Zig\u2022EM.</p> <p>As a stand-alone language, EM could introduce keywords like <code>config</code> and <code>proxy</code> to reinforce its novel concepts; and EM's language translator could impart very specific meanings to otherwise stock programming constructs like <code>module</code> and <code>interface</code>.</p> <p>Grafting EM onto Zig, however, requires us to operate within the syntactic and semantic constraints of the latter language; ensuring that EM's concepts and constructs don't become \"lost in translation\", so to speak, emerges as our greatest challenge.</p> <p>FULL DISCLOSURE \u2013 My first impressions of Zig</p> <p>Six months ago, I hadn't even heard\u2009 of Zig\u2009!!\u00a0 In the interim, of course, I've not only immersed myself in the language but also managed to field my first iteration of the Zig\u2022EM framework.</p> <p>To understand my ever-growing fascination with Zig, let's roll the clock back to the 1980s \u2013 a time in which C had firmly established itself as a universal \"middle-level\" language \u2013 used for system programming on 8-bit microprocessors, 16-bit mini-computers, and 32-bit mainframes alike.</p> <p>Like Zig, the C language has no inherent runtime environment supported across all target processors; building upon a \"bare-metal\" foundation, libraries of C functions (general-purpose or domain-specific) would address the runtime needs of a broad range of applications.</p> <p>Programmers generally characterize both C and Zig as inherently small\u2009 languages \u2013 embodying a set of rudimentary mechanisms for constructing higher-level libraries, while staying close to the underlying hardware.\u2009 As a consequence, C and Zig can remain maniacally focused on performance.(1)</p> <ol> <li>Andrew Kelley (the language's creator) refers  to Zig as a DSL for emitting machine code.</li> </ol> <p>Pursuing an analogy, I've always viewed C as a \"small town\" \u2013 one whose streets and neighborhoods I've come to know like the back of my hand.\u2009 By constrast, C++ has morphed into a \"big city\" \u2013 one with more streets than I could ever explore, and one with certain neighborhoods that the guide-books now tell me to avoid\u2009!!</p> <p>By maintaining a level of \"small town\" simplicity lacking in many modern compiled languages, Zig has emerged as a worthy alternative to C; this aspect of Zig also earns the language high-marks when compared against the complexity of Rust \u2013 another \"big city\" language that looks to supplant C++.  </p> <p>And finally, I can't say enough about the warm and welcoming Zig community I've joined at Ziggit \u2013 where you really do feel that \"small town\" vibe.\u00a0 </p>"},{"location":"post-002/#getting-started","title":"Getting started","text":"<p>You can provision Zig\u2022EM v25.0.1 on your host computer(1) in three simple steps:</p> <ol> <li>presently \u2013 <code>windows-x86_64</code>, <code>linux-x86_64</code>, <code>macos-x86_64</code></li> </ol> <p> \u00a0 download/unpack Zig v0.13.0, and add the <code>zig</code> command to your path  \u00a0 download/unpack the Zig\u2022EM sources, and <code>cd</code> into <code>zig-em-dev/workspace</code>  \u00a0 execute <code>zig build</code>, which will compile/install the Zig\u2022EM CLI program</p> <p>When finished, verify your installation by executing <code>zig build verify</code>:</p> <pre><code>[~/zig-em-dev/work]\n$ zig build verify\ncompiling HOST ...\n    board: LP_EM_CC2340R5\n    setup: ti.cc23xx://default\ncompiling TARG ...\n    image sha: 57a5b811\n    image size: text (1376) + const (364) + data (12) + bss (4)\ndone in 4.79 seconds\n</code></pre> Windows <p>You should install Git for Windows, which includes the Git Bash shell as well as other stock CLI tools.</p> <p>Going forward, we'll rely upon the <code>zig build zig-em</code> sub-command to compile designated Zig\u2022EM programs targeting a particular MCU.\u2009  For example, the following command explicitly compiles our verification example:</p> <pre><code>[~/zig-em-dev/work]\n$ zig build zig-em -- compile --unit=em.test/em.examples.basic/BlinkerP.em.zig \ncompiling HOST ...\n    board: LP_EM_CC2340R5     \n    setup: ti.cc23xx://default\ncompiling TARG ...\n    image sha: 57a5b811\n    image size: text (1376) + const (364) + data (12) + bss (4)\ndone in 4.67 seconds\n</code></pre> <p>Consider creating a <code>zig-em</code> command-line alias for the <code>zig build zig-em --</code> prefix shown above</p>"},{"location":"post-002/#exploring-zigem","title":"Exploring Zig\u2022EM","text":"<p>Zig\u2022EM supports just one target at this time \u2013 the Texas Instruments CC2340R5 wireless MCU featuring a low-power Arm Cortex-M0+ CPU, a familiar suite of embedded peripherals, and a generic 2.4\u2009GHz radio with BLE 5.x support.(1)</p> <ol> <li>While EM itself has supported dozens of 8/16/32-bit MCUs over the years, let's first focus on \"getting Zig\u2022EM right\" before we branch out to other hardware platforms.</li> </ol> <p>We strongly encourage you to purchase an inexpensive LP-EM-CC2340R5 board from TI in their popular LaunchPad\u2009 form-factor; you should also obtain this emulator board if you don't already have TI-XDS110 support through another LaunchPad.</p> MacOS <p>You'll also need to download TI-UniFlash and install the application at its default location.</p> <p>Armed with target hardware, we can now compile and\u2009 load our sample program by simply appending the <code>--load</code> (<code>-l</code>) option on our command-line:</p> <pre><code>[~/zig-em-dev/work]\n$ zig-em compile -u em.test/em.examples.basic/BlinkerP.em.zig -l\ncompiling HOST ...\n    board: LP_EM_CC2340R5\n    setup: ti.cc23xx://default\ncompiling TARG ...\n    image sha: 57a5b811\n    image size: text (1376) + const (364) + data (12) + bss (4)\ndone in 4.91 seconds\nloading...\ndone.\n</code></pre> <p>Use\u2009 <code>zig-em --help</code> followed by\u2009 <code>zig-em &lt;COMMAND&gt; --help</code> to learn more about the Zig\u2022EM CLI</p> <p>The <code>em.test/em.examples.basic</code> sub-folder contains over a dozen sample programs \u2013 each of which you can now compile and load onto your <code>LP-EM-CC2340R5</code> hardware.\u2009  While these programs do little more than blink LEDs, start immersing yourself in their overall structure:</p> em.examples.basic/BlinkerP.em.zig<pre><code>pub const em = @import(\"../../.gen/em.zig\");\npub const em__U = em.module(@This(), .{});\n\npub const AppLed = em.import.@\"em__distro/BoardC\".AppLed;\npub const Common = em.import.@\"em.mcu/Common\";\n\npub const EM__TARG = struct {\n    pub fn em__run() void {\n        AppLed.on();\n        for (0..10) |_| {\n            Common.BusyWait.wait(500_000);\n            AppLed.toggle();\n        }\n        AppLed.off();\n    }\n};\n</code></pre> <p>Our next few blog posts will deep-dive into this and other examples \u2013 focusing on core concepts and constructs first introduced in EM, but now seen through a Zig language lense.</p> <p>Browsing the Zig\u2022EM sources using VS Code</p> <p>The VS Code - Zig Language extension goes a long way towards streamlining your exploration of Zig\u2022EM through features such as syntax highlighting and code navigation; a companion language server (ZLS) enables outline views, hover help, and intellisense completion.</p> <p>At the same time, the Zig Language extension knows nothing about the Zig\u2022EM framework per se; the extension renders <code>BlinkerP.em.zig</code> no differently from <code>build.zig</code> or any other Zig source file.</p> <p>We'll shortly release a fork of the Zig extension and language server which (through some minor modifications) has rudimentary awareness of Zig\u2022EM.\u2009  As illustrated by the example above, files like <code>BlinkerP.em.zig</code> would now have their EM-based constructs distinctly highlighted \u2013 further flattening your learning curve.</p>"},{"location":"post-002/#looking-ahead","title":"Looking ahead","text":"<p>skill-up on the Zig language, using Karl Sequin's Learning Zig as a starting-point</p> <p>spend some cycles browsing the zig-em-dev snapshot downloaded earlier</p> <p>direct all questions/comments to this showcase post on the Ziggit forum</p> <p>Happy coding\u2009!!! \u2002  </p>"},{"location":"archive/2024/","title":"2024","text":""}]}