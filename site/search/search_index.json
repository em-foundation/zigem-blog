{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":""},{"location":"post-001/","title":"The EM language is dead, long live EM !!!","text":"<p>For the past fifteen years, the focus of the EM Programming Language has remained constant \u2013 producing \"tiny code for tiny chips\" where every byte of memory and \u03bcJoule of energy matters.\u2009  But now, I may have unwittingly come upon a better means\u2009 towards this end.</p> <p>\u21b7</p> <p></p>"},{"location":"post-001/#if-you-cant-beat-emzigem","title":"If you can't beat 'em,\u2002Zig\u2022EM","text":"<p>My zeal to promote EM earlier this year blinded me to the challenges of sustaining a novel programming language for resource-constrained embedded systems.\u2009  Supporting just a handful of developers over the past decade pales in comparison with the effort demanded to render EM openly and freely available to the broader embedded community.</p> <p>My (rhetorical) question to the community about the need to move beyond C (towards EM, of course\u2009!!\u2009) elicited a mixed bag of reactions \u2013 from \"cool, good luck\" \u2009to \"sorry, try again\"\u2009.\u2009 But then, I received this most consequential of comments which turned on the lights for me:\u00a0</p> <p>\"With a language like Zig I don't think there's need for EM\"</p> <p>FULL DISCLOSURE \u2013 You don't know what you don't know</p> <p>I pride myself on staying informed about the latest directions in programming language design and imple\u00admentation.\u2009  For me, programming languages lie at the heart of Computer Science; and for me, conceiving and evolving the EM language provided a personal path to the discipline's core.</p> <p>Honestly, I'd never even heard\u2009 of Zig when first receiving this comment several months ago.  While attending the Embedded World Conference in N\u00fcrnberg shortly thereafter, I informally polled dozens of attendees; and with the exception of my esteemed colleague Jeremy Bennett, no one had heard of the Zig programming language either.\u2009  Several folks did, however, know about zigbee\u00ae \u2013 which you'd expect from this crowd. </p> <p>Like EM, Zig offers higher-level programming with higher-levels of performance when compared with C; and Zig regularly earns high-marks when held up against other modern systems programming languages like Go and Rust \u2013 both already targeting embedded MCUs.</p> <p>But unlike the competition, Zig offers an inherent simplicity and transparency reminiscent of C \u2013 the incumbant systems programming language which some believe Zig could supplant.</p> <p>First released in early 2016, the Zig community supporting and sustaining this novel language continues to cast its net further and wider.\u2009 Compared with Go and Rust, however, Zig very much remains a work in progress \u2013 while capturing new followers (like me) on a daily basis.</p> <p>If you haven't already googled \"Zig programming language\", visit ziglang.org as a starting point.</p> <p>Suffice it say, far more folks have already lined up behind Zig than would ever even hear of the EM programming language.  To that end, I've decided to \"downgrade\" EM to a programming framework leveraging Zig as its host language \u2013 which finally leads us to Zig\u2022EM.</p> <p>It's Zig all the way down...</p> <p>As described here, the current rendition of EM \u2013 a transpiler written in TypeScript \u2013 generates a meta-program (implemented in NodeJS) whose hosted execution shapes a downstream run-time program (implemented in C/C++); the latter then compiles into firmware targeting some resource-constrained MCU platform.</p> <p>In the case of Zig\u2022EM, it will use just one language throughout its implementation \u2013 resulting in a 10\u2715 reduction in the amount of code I'll need to maintain; I can also leverage ZLS, an implementation of Microsoft's Language Server Protocol which enables Zig integration with VSCode and other popular IDEs.</p> <p>And above all, you can direct all questions\u2009/\u2009comments about the Zig language to the Zig community \u2013 as will I.</p> <p>As its overarching goal, the Zig\u2022EM framework strives to reconstitute the novel concepts and constructs first introduced within EM by using design-time patterns, build-time tooling, and run-time services \u2013 all leveraging the latest stable release of the Zig programming language.</p>"},{"location":"post-001/#plans-are-worthless","title":"Plans are worthless\u2009...","text":"<p>... but planning is everything\u2009.(1)\u00a0  Given our unanticipated change of course, let's set some new objectives for evolving the Zig\u2022EM framework through the remainder of this year:</p> <ol> <li>General Dwight D. Eisenhower,34th President of the United States</li> </ol> <p>focus exclusively on supporting the TI CC2340R5, which served as the initial hardware platform when EM debuted late last year; my enthusiasm for this wireless MCU hasn't waned in the interim\u2009!!</p> <p>create a suite of basic Zig\u2022EM examples \u2013 mimicking the dozen EM programs originally described here\u2009 \u2013 which would then illustrate how the framework maps EM constructs onto the Zig language</p> <p>benchmark the runtime performance of Zig\u2022EM in terms of program size, execution time, and power consumption \u2013 using our suite of basic examples along with a Zig-based re-work of EM\u2022Mark</p> <p>push forward with Zig\u2022EM support for the CC2340R5's 2.4\u2009GHz radio \u2013 eventually re-creating the minimalist BLE stack described here and measuring its performance against TI's legacy C code</p> <p>maintain a public Git repository containing the Zig\u2022EM framework source code \u2013 written entirely in Zig from the ground-up, and made openly available under an unconstrained MIT license</p> <p>I'll try to post regular updates on progress towards these objectives, along with some high-level tours as Zig\u2022EM takes shape.\u2009  Let's see what happens, as we do live in interesting times\u2009!!</p>"},{"location":"post-001/#how-you-can-get-involved","title":"How you can get involved","text":"<p>explore the Zig language \u2013 I highly recommend Karl Sequin's Learning Zig as a starting-point</p> <p>experience the \"Zen of Zig\" at the Ziggit forum \u2013 a refreshing respite from the rants at Reddit</p> <p>read my first post about Zig\u2022EM to the Zig dev community  \u2013 then sign-up and send me some </p> <p>Happy coding\u2009!!! \u2002  </p>"},{"location":"post-002/","title":"Announcing Zig\u2022EM v25.0.1","text":"<p>With support from The EM Foundation, we announce the initial release of Zig\u2022EM \u2013 a novel programming framework for developing and deploying applications which target resource-constrained MCUs, where every byte of memory and every \u03bcJoule of energy matters.</p> <p>\u21b6</p> <p>\u21b7</p>"},{"location":"post-002/#setting-expectations","title":"Setting expectations","text":"<p>As rationalized in our previous post, Zig\u2022EM strives to reconstitute\u2009 core concepts and constructs of the EM Programming Language into Zig \u2013 a system programming language favorably compared with Go and Rust, but with the simplicity and transparency of C. </p> <p>But downgrading the EM language into a programming framework hosted by Zig does introduce some challenges.\u2009 For one, the Zig language itself remains a work-in-progress; reaching an \"official\" Zig 1.0 release will realistically require years of effort.(1)</p> <ol> <li>see Andrew Kelley's Zig 2024 Roadmap talk</li> </ol> <p>Furthermore, Zig eschews much of the \"syntactic flexibility\" (operator overloading, optional lexical elements, etc) found in contemporary languages ranging from C++ to Ruby \u2013 leaving us with a somewhat rudimentary set of programmatic mechanisms to realize Zig\u2022EM.</p> <p>As a stand-alone language, EM could introduce keywords like <code>config</code> and <code>proxy</code> to reinforce its novel concepts; and EM's language translator could impart very specific meanings to otherwise stock programming constructs like <code>module</code> and <code>interface</code>.</p> <p>Grafting EM onto Zig, however, requires us to operate within the syntactic and semantic constraints of the latter language.\u2009 Ensuring that EM's concepts and constructs don't become \"lost in translation\", so to speak, emerges as our greatest challenge.</p> <p>FULL DISCLOSURE \u2013 My first impressions of Zig</p> <p>Six months ago, I hadn't even heard\u2009 of Zig\u2009!!\u00a0 In the interim, of course, I've not only immersed myself in the language but also managed to field my first iteration of the Zig\u2022EM framework.</p> <p>To understand my ever-growing fascination with Zig, let's roll the clock back to the 1980s \u2013 a time in which C had firmly established itself as a universal \"middle-level\" language \u2013 used for system programming on 8-bit microprocessors, 16-bit mini-computers, and 32-bit mainframes alike.</p> <p>Like Zig, the C language has no inherent runtime environment supported across all target processors.\u2009 Building upon a \"bare-metal\" foundation, libraries of C functions (general-purpose or domain-specific) would address the runtime needs of a broad range of applications.</p> <p>Programmers generally characterize both C and Zig as inherently small\u2009 languages \u2013 embodying a set of rudimentary mechanisms for constructing higher-level libraries, while staying close to the underlying hardware.\u2009 As a consequence, C and Zig can remain maniacally focused on performance.(1)</p> <ol> <li>Andrew Kelley (the language's creator) refers  to Zig as a DSL for emitting machine code.</li> </ol> <p>Pursuing an analogy, I've always viewed C as a \"small town\" \u2013 one whose streets and neighborhoods I've come to know like the back of my hand.\u2009 By constrast, C++ has morphed into a \"big city\" \u2013 one with more streets than I could ever explore, and one with certain neighborhoods that the guide-books now tell me to avoid\u2009!!</p> <p>By maintaining a level of \"small town\" simplicity lacking in many modern compiled languages, Zig has emerged as a worthy alternative to C.\u2009 This aspect of Zig also earns the language high-marks when compared against the complexity of Rust \u2013 another \"big city\" language that looks to supplant C++.  </p> <p>And finally, I can't say enough about the warm and welcoming Zig community I've joined at Ziggit \u2013 where you really do feel that \"small town\" vibe.\u00a0 </p>"},{"location":"post-002/#getting-started","title":"Getting started","text":"<p>We've updated this material to reflect the latest release of Zig\u2022EM</p> <p>You can provision Zig\u2022EM v25.0.x on your host computer(1) in three simple steps:</p> <ol> <li>presently \u2013 <code>windows-x86_64</code>, <code>linux-x86_64</code>, <code>macos-x86_64</code></li> </ol> <p> \u00a0 download/unpack Zig v0.13.0, and add the <code>zig</code> command to your path  \u00a0 download/unpack the latest Zig\u2022EM sources, and <code>cd</code> into <code>zigem-dev/workspace</code>  \u00a0 execute <code>zig build</code>, which will compile/install the Zig\u2022EM CLI program</p> <p>When finished, verify your installation by executing <code>zig build verify</code>:</p> <p><pre><code>[zigem-dev/workspace]\n$ zig build verify\ncompiling META ...\n    board: LP_EM_CC2340R5\n    setup: ti.cc23xx://default\ncompiling TARG ...\n    image sha: 57a5b811\n    image size: text (1376) + const (364) + data (12) + bss (4)\ndone in 4.79 seconds</code></pre></p> Windows <p>You should install Git for Windows, which includes the Git Bash shell as well as other stock CLI tools.</p> <p>Going forward, we'll rely upon the <code>zig build zigem</code> sub-command to compile designated Zig\u2022EM programs targeting a particular MCU.\u2009  For example, the following command explicitly compiles our verification example:</p> <p><pre><code>[zigem-dev/workspace]\n$ zig build zigem -- compile -f em.core/em.examples.basic/BlinkerP.em.zig\ncompiling META ...\n    board: LP_EM_CC2340R5\n    setup: ti.cc23xx://default\ncompiling TARG ...\n    image sha: 57a5b811\n    image size: text (1376) + const (364) + data (12) + bss (4)\ndone in 4.67 seconds</code></pre></p> <p>Consider creating a <code>zigem</code> command-line alias for the <code>zig build zigem --</code> prefix shown above</p>"},{"location":"post-002/#exploring-zigem","title":"Exploring Zig\u2022EM","text":"<p>Zig\u2022EM supports just one target at this time \u2013 the Texas Instruments CC2340R5 wireless MCU featuring a low-power Arm Cortex-M0+ CPU, a familiar suite of embedded peripherals, and a generic 2.4\u2009GHz radio with BLE 5.x support.(1)</p> <ol> <li>While EM itself has supported dozens of 8/16/32-bit MCUs over the years, let's first focus on \"getting Zig\u2022EM right\" before we branch out to other hardware platforms.</li> </ol> <p>We strongly encourage you to purchase an inexpensive LP-EM-CC2340R5 board from TI in their popular LaunchPad\u2009 form-factor.\u2009 In addition, you should obtain this emulator board if you don't already have TI-XDS110 support through another LaunchPad.</p> MacOS <p>You'll also need to download TI-UniFlash and install the application at its default location.</p> <p>Armed with target hardware, we can now compile and\u2009 load our sample program by simply appending the <code>--load</code> (<code>-l</code>) option on our command-line:</p> <p><pre><code>[zigem-dev/workspace]\n$ zigem compile -f em.core/em.examples.basic/BlinkerP.em.zig -l\ncompiling META ...\n    board: LP_EM_CC2340R5\n    setup: ti.cc23xx://default\ncompiling TARG ...\n    image sha: 57a5b811\n    image size: text (1376) + const (364) + data (12) + bss (4)\ndone in 4.91 seconds\nloading...\ndone.</code></pre></p> <p>Use\u2009 <code>zigem --help</code> followed by\u2009 <code>zigem &lt;COMMAND&gt; --help</code> to learn more about the Zig\u2022EM CLI.</p> <p>The <code>em.core/em.examples.basic</code> sub-folder contains over a dozen sample programs \u2013 each of which you can now compile and load onto your <code>LP-EM-CC2340R5</code> hardware.\u2009  While these programs do little more than blink LEDs, start immersing yourself in their overall structure:</p> em.examples.basic/BlinkerP.em.zig<pre><code>pub const em = @import(\"../../zigem/em.zig\");\npub const em__U = em.module(@This(), .{});\n\npub const AppLed = em.import.@\"em__distro/BoardC\".AppLed;\npub const Common = em.import.@\"em.mcu/Common\";\n\npub const EM__TARG = struct {\n    pub fn em__run() void {\n        AppLed.on();\n        for (0..10) |_| {\n            Common.BusyWait.wait(500_000);\n            AppLed.toggle();\n        }\n        AppLed.off();\n    }\n};\n</code></pre> <p>Our next few blog posts will deep-dive into this and other examples \u2013 focusing on core concepts and constructs first introduced in EM\u2009, but now seen through a Zig language lense.</p> <p>Browsing the Zig\u2022EM sources using VS Code</p> <p>The VS Code - Zig Language extension goes a long way towards streamlining your exploration of Zig\u2022EM through features such as syntax highlighting and code navigation; a companion language server (ZLS) enables outline views, hover help, and intellisense completion.</p> <p>At the same time, the Zig Language extension knows nothing about the Zig\u2022EM framework per se; the extension renders <code>BlinkerP.em.zig</code> no differently from <code>build.zig</code> or any other Zig source file.</p> <p>We'll now released a fork of the Zig extension and language server which (through some minor modifications) has rudimentary awareness of Zig\u2022EM.\u2009  As illustrated by the example above, files like <code>BlinkerP.em.zig</code> would now have their EM-based constructs distinctly highlighted \u2013 further flattening your learning curve.</p>"},{"location":"post-002/#looking-ahead","title":"Looking ahead","text":"<p>skill-up on the Zig language, using Karl Sequin's Learning Zig as a starting-point</p> <p>spend some cycles browsing the zigem-dev snapshot downloaded earlier</p> <p>direct all questions/comments to this showcase post on the Ziggit forum</p> <p>Happy coding\u2009!!! \u2002  </p>"},{"location":"post-003/","title":"Touring the Zig\u2022EM code-scape","text":"<p>The next few blog posts will explore the Zig\u2022EM programming framework in ever-greater detail \u2013 starting with instructions for installing the latest software version, and then moving on to a 10,000' overview that touches upon some core concepts and constructs of Zig\u2022EM.</p> <p>\u21b6</p>"},{"location":"post-003/#updating-your-installation","title":"Updating your installation","text":"<p>The process for (initially) installing and (subsequently) updating your local version of Zig\u2022EM boils down to three basic steps:</p> <p> \u00a0 install Zig  \u00a0 clone zigem-dev  \u00a0 execute <code>zig build</code></p> <p>As part of step , you should have added the <code>zig</code> executable to your path.\u2009 Invoke the <code>zig version</code> command for confirmation.(1)</p> <ol> <li>Zig\u2022EM currently requires version 0.13.0 of Zig</li> </ol> <p>As for step , an initial <code>git clone</code> and subsequent <code>git pull</code> of the <code>zigem-dev</code> repository will take you to the latest release of Zig\u2022EM.\u2009 Tags on the main branch (<code>v25.0.1</code>, <code>v25.0.2</code>, ...) enable you to easily move to earlier releases.(1)</p> <ol> <li>If you wish to avoid the <code>git</code> command altogether, justdownload the sources for individual releases.</li> </ol> <p>Step  will then build the <code>zigem</code> command-line executable, as well as download/install other required artifacts.\u2009 Invoke <code>zig build verify</code> as a final test.</p> <p>You may want to consult these Getting started instructions for more detail on first-time installation.</p> <p>The Zig cache \u2014 a cornerstone of <code>zig build</code></p> <p>As you might expect, the first invocation of <code>zig build</code> can take a fair amount of time; subsequent invocations of <code>zig build</code>, however, can complete almost instantenously.\u2009  Not unlike <code>make</code>, the zig build-system strives to perform the minimal number of steps required to complete the task at hand.</p> <p>Should you choose to learn more(1)about the build-system, you'll quickly come to appreciate the critical role played by the Zig cache \u2013 a fascinating foundational element first described here in detail.\u2009  In simple terms, virtually any artifact touched when invoking <code>zig build</code> will persist in Zig's filesystem cache.</p> <ol> <li>ziglang.orgzig.newskristoff.itmichelh.com</li> </ol> <p>Strange as it may seem, you won't find anything resembling a <code>zig clean</code> command; all cached artifacts have a unique content-based identifier.\u2009  But sometimes to alleviate any lingering doubts about cache coherence, I will delete the special <code>.zig-cache/</code> and <code>zig-out/</code> folders in the repository's root before invoking <code>zig build</code>. </p> <p>The artifacts provisioned through <code>zig build</code> include a version of this Zig Language extension for VS Code \u2013 specially modified to add awarenesss of the Zig\u2022EM framework.\u2009 Forked from upstream repositories, this extension currently functions as a \"drop-in\" replacement.(1)</p> <ol> <li>If you've already installed the stock Zig Language extension,you'll have to disable it within the <code>zigem-dev</code> workspace.</li> </ol> <p>To install, invoke Extensions: Install from VSIX... from the VS Code Command Palette and then navigate to your <code>zigem-dev/zig-out/tools/</code> folder.\u2009 This folder should contain a file named <code>vscode-zigem-VERSION.vsix</code>, which you can now select and Install.(1)</p> <ol> <li>If you find multiple <code>.vsix</code> files in the folder, select the one with the highest <code>VERSION</code> number.</li> </ol> <p>Once complete, invoke Command Palette &gt; Developer: Reload Window to refresh your workspace.\u2009 If all goes as planned, you'll see a Zig\u2022EM activated popup appear briefly.</p>"},{"location":"post-003/#repository-organization","title":"Repository organization","text":"<p>With our <code>vscode-zigem</code> extension in place, let's start exploring the <code>zigem-dev</code> repository itself \u2013 beginning with its top-level organization as a \"typical\" Zig project:</p> <p></p> Zig Project   <p>It all starts with <code>build.zig</code></p> <p>Even if you never plan to follow-up on the <code>zig build</code> references cited earlier, do invest under a minute of your valuable time digesting this material found at zig.guide.</p> <p>Drilling down into the special <code>workspace/</code> folder highlighted above, we formally enter the domain of Zig\u2022EM \u2013 featuring a number of packages with (unique) names like <code>em.core</code>, which in turn contain (uniquely-named) buckets such as <code>em.utils</code> and <code>em.examples.basic</code>.</p> <p></p> Zig\u2022EM Workspace   <p>A Zig\u2022EM workspace contains a special <code>zigem.ini</code> file at its root, along with a distinguished <code>zigem-package.ini</code> file at the top of each package found therein.\u2009 We'll visit these as well as other <code>.ini</code> configuration files over the course of time.</p> <p>Descending one more level in our package &gt; bucket hiearchy, we come to individual compilation units \u2013 Zig source files which uses a novel <code>\"em\"</code> library provided by the Zig\u2022EM framework.\u2009 A special <code>.em.zig</code> file extension plus an associated icon visually distinguish a Zig\u2022EM unit from \"ordinary\" Zig sources [<code>src/*.zig</code>] depicted earlier.</p> <p></p> Zig\u2022EM Units   <p>We'll soon take a closer look at the <code>BlinkerP.em.zig</code> and <code>FiberP.em.zig</code> source files.</p> <p>By design, Zig\u2022EM limits its package &gt; bucket &gt; unit hiearchy to just three levels.\u2009 The names chosen for top-level packages and their constituent buckets will, however, often assume a <code>long.qualified.form</code> \u2013 used to ensure a measure of uniqueness and durability.</p> <p>A hierarchical namespace for buckets and packages</p> <p>Zig\u2022EM favors a namespace hierarchy when labeling individual buckets and packages, in which the supplier has a globally-unique prefix\u2009 [<code>\"org.&lt;domain&gt;\"</code>, <code>\"git.&lt;userid&gt;\"</code>, etc\u2009] used in these element names.</p> <p>Having said that, buckets and packages supplied by The EM Foundation itself [<code>\"git.em-foundation\"</code>] will often use a shorter (though still unique) moniker such as <code>\"em.\"</code> for their namespace prefix.</p> <p>Another Zig\u2022EM convention:\u00a0 names ascribed to buckets should themselves remain globally-unique \u2013 independent of their containing package(s), which also should have unique names.</p> <p>While the <code>\"em.arch.arm\"</code> bucket lives in the <code>\"em.core\"</code> package, a third-party [<code>\"git.biosbob\"</code>] could also supply a package (labeled with their own prefix) that contains buckets with the same legacy <code>\"em.**\"</code> names.</p> <p>As we'll see shortly, individual Zig\u2022EM source files use a special <code>em.import</code> operator to reference other units found in the workspace.\u2009 By design, each unit has a canonical name\u2009 of the form <code>bucket/Unit</code>:\u00a0 <code>em.examples.basic/BlinkerP</code>, <code>ti.distro.cc23xx/BoardC</code>, etc.</p> <p>While buckets ultimately reside within packages, individual <code>.em.zig</code> source files should never reference the latter by name.\u2009 Zig\u2022EM units in fact remain oblivious to any package(s) containing their own bucket as well as other <code>bucket/Unit</code> elements they may import.</p> <p>In essence, packages provide a delivery vehicle for <code>bucket/Unit</code> content.\u2009 Each package has a manifest (<code>zigem-package.ini</code>) which in general names other packages upon which it depends.\u2009 Zig\u2022EM topologically sorts the (acyclic) dependency relation amongst all packages in the workspace, yielding a search path used when resolving <code>bucket/Unit</code> references.</p> <p>Terminology\u2009:: Zig\u2022EM = Zig + EM</p> <p>Mapping the original EM language into Zig can lead to terminology clashes, in which elements like package have distinct meanings in each language domain.\u2009 EM, for instance, featured a bundle &gt; package &gt; unit hierarchy.\u2009 For consistency, Zig\u2022EM will favor using native Zig nomenclature as much as possible.</p> <p>Over time, we'll directly leverage Zig Package Management mechanisms for delivering buckets of Zig\u2022EM content.\u2009 Said another way, expect each Zig\u2022EM package to carry their own <code>build.zig</code> and <code>build.zig.zon</code> files.\u2009  We'll also use Zig modules in <code>build.zig</code> to define <code>bucket/Unit</code> names exposed by the package.</p> <p>The <code>workspace/</code> folder depicted earlier currently serves as an embryonic prototype \u2013 delivered as part of the <code>zigem-dev</code> repository.\u2009 When we reach Zig\u2022EM v25.1.0, however, users will create their own workspace(s) populated with multiple packages from multiple suppliers \u2013 each bundling uniquely-labeled <code>bucket/Unit</code> content.</p>"},{"location":"post-003/#source-code-constructs","title":"Source code constructs","text":"<p>Zig\u2022EM units, as noted earlier, reside in <code>.em.zig</code> source files and make use of a special <code>\"em\"</code> library.\u2009 In all other respects, these files conform to the syntax and semantics of Zig.</p> <p>For Zig-lings and Zig-gurus alike....</p> <p>As you explore the dozens of <code>.em.zig</code> files found in the workspace, we recognize that your knowledge of Zig can vary considerably.\u2009 We'll do our best to literally and figuratively <code>highlight</code> Zig\u2022EM's unique constructs.</p> <p>For those seeing the Zig language for the first time, we strongly recommend Learning Zig by Karl Sequin.\u2009 For those coming from the embedded space with a background in C, you'll find some further motivation behind Zig in this @avestura blog post as well as this Zig in 100 Seconds video.</p> <p>And for the Zig gurus:\u00a0 we always welcome your insightful comments at ziggit.dev on how to best leverage the underlying language in implementing the core concepts and constructs of the Zig\u2022EM framework.</p> <p>To begin, let's focus on the <code>em.examples.basic/BlinkerP</code> program which illustrates some rudimentary constructs commonly found in a Zig\u2022EM unit:</p> em.examples.basic/BlinkerP.em.zig<pre><code>pub const em = @import(\"../../zigem/em.zig\");\npub const em__U = em.module(@This(), .{});\n\npub const AppLed = em.import.@\"em__distro/BoardC\".AppLed;\npub const Common = em.import.@\"em.mcu/Common\";\n\npub const EM__TARG = struct {\n    pub fn em__run() void {\n        AppLed.on();\n        for (0..10) |_| {\n            Common.BusyWait.wait(500_000);\n            AppLed.toggle();\n        }\n        AppLed.off();\n    }\n};\n</code></pre> <p>Even with no prior knowledge of the Zig language, the behavior of the \"main\" function between lines 8 and 15 should seem obvious \u2013 toggling <code>AppLed</code> ten times every half-second.</p> <p>Standing back, the first two lines of this file serve as boilerplate which you'll find in every Zig\u2022EM unit:\u00a0 line 1 imports our special <code>\"em\"</code> library, while line 2 declares this unit's role as an <code>em.module</code> and binds a corresponding object to the <code>em__U</code> framework constant.</p> <p>language keywords versus framework operators</p> <p>The EM language introduced the keywords <code>module</code>, <code>interface</code>, <code>composite</code>, and <code>template</code> to declare the role played by a specific unit;\u2009 the Zig\u2022EM framework uses its operators <code>em.module</code>, <code>em.interface</code>, etc. for a similar purpose.\u2009  While Zig\u2022EM modules predominate, you will see other sorts of units in due course.</p> <p>Lines 4\u20135 use the framework's <code>em.import</code> operator to access <code>em.mcu/Common</code>, as well as the <code>BoardC</code> (composite) unit located in a logical\u2009 bucket named <code>em__distro</code>.(1) The <code>BoardC</code> composite in turn aggregates a large number of modules featuring hardware-specific implementations [<code>AppLed</code>] of hardware-independent interfaces [<code>em.hal/AppLedI</code>]\u2009.</p> <ol> <li>currently bound to <code>ti.distro.cc23xx</code> within our workspace's <code>zigem.ini</code> configuration file</li> </ol> <p>Finally, the <code>EM_TARG</code> structure defined at line 7 introduces a new lexical scope containing other Zig declarations (constants, types, variables, functions).\u2009 We'll explain the role of this special <code>struct</code> once we examine the lengthier <code>em.examples.basic/FiberP</code> program:</p> <p>em.examples.basic/FiberP.em.zig<pre><code>pub const em = @import(\"../../zigem/em.zig\");\npub const em__U = em.module(@This(), .{});\npub const em__C = em__U.config(EM__CONFIG);\n\npub const EM__CONFIG = struct {\n    blinkF: em.Param(FiberMgr.Obj),\n};\n\npub const AppLed = em.import.@\"em__distro/BoardC\".AppLed;\npub const Common = em.import.@\"em.mcu/Common\";\npub const FiberMgr = em.import.@\"em.utils/FiberMgr\";\n\npub const EM__META = struct {\n    //\n    pub fn em__constructH() void {\n        const blinkF = FiberMgr.createH(em__U.fxn(\"blinkFB\", FiberMgr.BodyArg));\n        em__C.blinkF.set(blinkF);\n    }\n};\n\npub const EM__TARG = struct {\n    //\n    const blinkF = em__C.blinkF;\n\n    pub fn em__run() void {\n        blinkF.post();\n        FiberMgr.run();\n    }\n\n    var count: u8 = 5;\n\n    pub fn blinkFB(_: FiberMgr.BodyArg) void {\n        em.@\"%%[d]\"();\n        count -= 1;\n        if (count == 0) em.halt();\n        AppLed.on();\n        Common.BusyWait.wait(100_000);\n        AppLed.off();\n        Common.BusyWait.wait(100_000);\n        blinkF.post();\n    }\n};\n</code></pre> This sample program illustrates basic use of <code>em.utils/FiberMgr</code> \u2013 a module delivered within the <code>em.core</code> package, and which manages lightweight threads of type <code>FiberMgr.Obj</code> using a factory design pattern applied often within Zig\u2022EM.</p> <p>Looking first at the features declared and defined within the <code>EM__TARG</code> scope, we find:</p> <p> line 23 \u2014 the constant <code>blinkF</code>, which references a <code>Fiber.Obj</code> created earlier in the program line 25 \u2014 the framework function <code>em__run</code>, which serves as this example's runtime entry-point line 30 \u2014 the variable <code>count</code>, used to track the number of times the program must blink <code>AppLed</code> line 32 \u2014 the function <code>blinkFB</code>, which represents the code executed upon activating the <code>blinkF</code> fiber </p> <p>We'll fill in some more details after we examine the top-half of <code>em.examples.basic/FiberP</code>.</p> <p>Complementing <code>EM__TARG</code>, the <code>FiberP</code> program also declares <code>EM__META</code> beginning at line 13.\u2009 Here too, this special <code>struct</code> can contain declarations and definitions within its scope:</p> <p> line 15 \u2014 the framework function <code>em__constructH</code>, which creates the <code>blinkF</code> fiber used later in the program line 16 \u2014 <code>FiberMgr</code>.<code>createH</code> also binds our (runtime) <code>blinkFB</code> function to the newly-created <code>blinkF</code> fiber </p> <p>To complete the picture, line 5 of the <code>FiberP</code> program defines a special <code>EM__CONFIG</code> structure \u2013 an instance of which the program assigns to the <code>EM__C</code> framework constant using more boilerplate code back at line 3.</p> <p>VS Code snippets</p> <p>The <code>vscode.zigem</code> extension includes boilerplate code which you can inject into new units within your workspace.\u2009 Invoke Command Palette &gt; Snippets: Fill File with Snippet on an empty <code>.em.zig</code> file to experiment.</p> <p>To appreciate the pivotal role played by the <code>EM__C</code><code>.</code><code>blinkF</code> field throughout our <code>FiberP</code> example, we'll need to examine how the Zig\u2022EM framework transforms the <code>FiberP.em.zig</code> source file into an executable program image.</p>"},{"location":"post-003/#program-compilation","title":"Program compilation","text":"<p>Let's now compile the <code>em.examples.basic/FiberP</code> program, using the framework's <code>zigem</code> command first seen here:</p> <p><pre><code>[zigem-dev/workspace]\n$ zigem compile -f em.core/em.examples.basic/FiberP.em.zig\ncompiling META ...\n    board: LP_EM_CC2340R5\n    setup: ti.cc23xx://default\ncompiling TARG ...\n    image sha: 93aad9c9\n    image size: text (1560) + const (0) + data (40) + bss (4)\ndone in 6.96 seconds</code></pre></p> <p>You'll immediately notice that <code>zigem</code> compiles the program twice\u00a0:\u00a0 once for the META domain, and then again for the TARG domain.</p> <p>The META compilation stage processes all source code from lines 1\u201319, effectively merging the <code>EM__META</code> declarations into the top-level file scope.\u2009</p> <p>The TARG compilation stage follows suit, combining common declarations [1\u201311] with <code>EM__TARG</code> declarations [21\u201342] as input for the underlying Zig compiler.</p> <p>While diving into the implementation details of the <code>zigem</code> command lies well beyond the scope of this introductory article, we'll give you a quick peek into the Zig\u2022EM \"basement\" where most of the magic occurs.</p> <p>For those in the know, just follow the trail heading out from <code>build.zig</code> and <code>src/main.zig</code>\u2009....</p> <p>To start, invoke the <code>zigem clean</code> command followed by <code>zigem refresh</code>.\u2009 Your workspace should now reveal two additional elements generated by the framework:</p> <p></p> Generated Elements   <p>The <code>.zigem-main.zig</code> file provides entry points for the META and TARG compilatiion stages, which at this point respectively reference empty <code>zigem/meta.zig</code> and <code>zigem/targ.zig</code> files.</p> <p>You'll find the \"interesting\" code generated at this stage in files like <code>imports.zig</code>, which reflects an upfront discovery of all package &gt; bucket &gt; unit elements in the workspace.</p> <p>You'll also find a <code>makefile</code>, whose recipes will eventually migrate into (generated) <code>build.zig</code> files.</p> <p>By invoking <code>zigem compile</code> with its <code>-m</code> [<code>--meta</code>] option, we can better appreciate the role played by this initial compilation stage.</p> <p><pre><code>[zigem-dev/workspace]\n$ zigem compile -f em.core/em.examples.basic/FiberP.em.zig -m\ncompiling META ...\n    board: LP_EM_CC2340R5\n    setup: ti.cc23xx://default\ndone in 4.73 seconds</code></pre></p> <p>Before compilation begins, the framework populates <code>zigem/meta.zig</code> with code that will execute our new META program \u2013 rooted at the <code>em.examples.basic/FiberP</code> unit and incorporating all other units (recursively) reached through <code>em.import</code>.</p> <p>Next, the framework invokes the Zig compiler using the <code>zig build-exe</code> command and then runs the <code>zigem/out/meta-main</code> executable image output by the compiler.\u2009 The <code>meta</code> goal inside <code>zigem/makefile</code> currently codifies the steps used in this process.</p> <p>If not obvious, META programs run on your host PC \u2014 and not on resource-constrained target HW\u2009!!!</p> <p>Functions like <code>em__constructH</code> [\u2009defined in the <code>FiberP</code> <code>EM__META</code> scope at 13] enjoy execution in an environment with virtually unlimited memory and processing resources, as well as access to the host's file system or even the internet if necessary.</p> <p>In general, META programs declare config parameters as fields within per-unit <code>EM__CONFIG</code> structures [5] and modify their values [17] via local definitions of <code>em__C</code>.\u2009 Ultimately, Zig\u2022EM writes the final state of all program config parameters into an updated <code>zigem/targ.zig</code> file.</p> <p>In general, META programs declare config parameters as fields within per-unit <code>EM__CONFIG</code> structures [5] and modify their values [17] via local definitions of <code>em__C</code>.\u2009 Ultimately, Zig\u2022EM updates its <code>zigem/targ.zig</code> file to reflect the final state of all program config parameters.</p> <p>A config parameter acts like a <code>var</code> in your META program, but like a <code>const</code> in your TARG program.</p> <p>The downstream compilation of <code>FiberP</code> for the TARG domain uses a public <code>exec</code> function defined at the bottom of <code>zigem/targ.zig</code> as the runtime entry-point.\u2009 After initializing the target hardware(1)<code>exec</code> will call the <code>em__run</code> function [25] defined in <code>BlinkerP</code>.</p> <ol> <li>via special function like <code>em__reset</code> and <code>em__startup</code>defined in lower-level program units</li> </ol> <p>To summarize:\u00a0 We have a hosted upstream META program that outputs constant data consumed by a downstream (cross-compiled) TARG program.  This novel two-stage build flow ultimately yields highly-optimized\u2009 executable images for resource-constrained MCU platforms:</p> <p>To summarize:</p> <p>\u00a0 a hosted upstream META program manipulates CONFIG parameters as variables \u00a0 a downstream TARG program consumes these (constant) parameters when cross-compiled \u00a0 a novel build flow which ultimately yields highly-optimized\u2009 firmware  for resource-constrained MCUs</p> <p><pre><code>[zigem-dev/workspace]\n$ zigem compile -f em.core/em.examples.basic/FiberP.em.zig\ncompiling META ...\n    board: LP_EM_CC2340R5\n    setup: ti.cc23xx://default\ncompiling TARG ...\n    image sha: 93aad9c9\n    image size: text (1560) + const (0) + data (40) + bss (4)\ndone in 6.96 seconds</code></pre></p>"},{"location":"post-003/#further-exploration","title":"Further exploration","text":"<p>Depending upon your background and interests, we present you with several different paths for increasing your understanding of the Zig\u2022EM framework:</p> <p>More sample programs...</p> <p>  \u00a0 visit other sample programs in the <code>em.examples.basic</code> bucket  \u00a0 load these programs onto target hardware, following these instructions</p> <p>Go deep</p> <p>  \u00a0 familiarize yourself with the other <code>em.**</code> buckets, as well as the <code>ti.**</code> content  \u00a0 starting with <code>AppLed</code>, plumb down through all units contributing to its implementation </p> <p>Behind the curtain...</p> <p>  \u00a0 get dirty inside of <code>em.zig</code> and <code>meta-main.zig</code>, found in the <code>em.lang</code> bucket  \u00a0 offer up guidance on how to better leverage the Zig language and its build system</p> <p>Happy coding\u2009!!! \u2002  </p>"},{"location":"archive/2024/","title":"2024","text":""}]}